$date
	Mon Dec  5 18:03:47 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Processor_Top_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst_n $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 1 # zero_out $end
$var wire 32 $ sign_ext_out [31:0] $end
$var wire 32 % read_data2 [31:0] $end
$var wire 32 & read_data1 [31:0] $end
$var wire 32 ' out_address [31:0] $end
$var wire 32 ( jump_address [31:0] $end
$var wire 28 ) j_lower_28 [27:0] $end
$var wire 32 * instrn [31:0] $end
$var wire 1 + final_write_en $end
$var wire 32 , datamem_read_data [31:0] $end
$var wire 1 - ctrl_write_en $end
$var wire 5 . ctrl_write_addr [4:0] $end
$var wire 32 / ctrl_regwrite_data [31:0] $end
$var wire 32 0 ctrl_in_address [31:0] $end
$var wire 1 1 ctrl_datamem_write_en $end
$var wire 32 2 ctrl_aluin2 [31:0] $end
$var wire 32 3 branch_address [31:0] $end
$var wire 32 4 branch_addr_offset [31:0] $end
$var wire 32 5 alu_result [31:0] $end
$var wire 32 6 address_plus_4 [31:0] $end
$var wire 32 7 addr_incr [31:0] $end
$scope module adder_branch_addr $end
$var wire 32 8 in2 [31:0] $end
$var wire 32 9 in1 [31:0] $end
$var reg 32 : out [31:0] $end
$upscope $end
$scope module adder_next_addr $end
$var wire 32 ; in2 [31:0] $end
$var wire 32 < in1 [31:0] $end
$var reg 32 = out [31:0] $end
$upscope $end
$scope module alu $end
$var wire 6 > func_field [5:0] $end
$var wire 6 ? opcode [5:0] $end
$var wire 1 # zero $end
$var wire 32 @ result [31:0] $end
$var wire 3 A alu_control [2:0] $end
$var wire 32 B B [31:0] $end
$var wire 32 C A [31:0] $end
$scope module alu_core_inst $end
$var wire 1 # zero $end
$var wire 3 D alu_control [2:0] $end
$var wire 32 E B [31:0] $end
$var wire 32 F A [31:0] $end
$var reg 32 G result [31:0] $end
$upscope $end
$scope module alu_ctrlr_inst $end
$var wire 6 H func_field [5:0] $end
$var wire 6 I opcode [5:0] $end
$var reg 3 J alu_control [2:0] $end
$var reg 3 K func_code [2:0] $end
$upscope $end
$upscope $end
$scope module concat_jump_addr $end
$var wire 32 L address_plus_4 [31:0] $end
$var wire 32 M jump_address [31:0] $end
$var wire 28 N bits28_in [27:0] $end
$upscope $end
$scope module ctrl_logic $end
$var wire 32 O address_plus_4 [31:0] $end
$var wire 32 P alu_result [31:0] $end
$var wire 32 Q branch_address [31:0] $end
$var wire 1 - ctrl_write_en $end
$var wire 6 R instrn_opcode [5:0] $end
$var wire 32 S jump_address [31:0] $end
$var wire 1 # zero_out $end
$var wire 32 T sign_ext_out [31:0] $end
$var wire 32 U read_data2 [31:0] $end
$var wire 32 V instrn [31:0] $end
$var wire 32 W datamem_read_data [31:0] $end
$var wire 5 X ctrl_write_addr [4:0] $end
$var wire 32 Y ctrl_regwrite_data [31:0] $end
$var wire 32 Z ctrl_in_address [31:0] $end
$var wire 1 1 ctrl_datamem_write_en $end
$var wire 32 [ ctrl_aluin2 [31:0] $end
$var wire 1 \ branch_or_address_plus_4 $end
$upscope $end
$scope module data_mem $end
$var wire 32 ] address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 1 write_en $end
$var wire 32 ^ write_data [31:0] $end
$var wire 32 _ read_data [31:0] $end
$upscope $end
$scope module instr_mem $end
$var wire 32 ` instrn_address [31:0] $end
$var wire 32 a instrn [31:0] $end
$upscope $end
$scope module prg_cntr $end
$var wire 1 ! clk $end
$var wire 32 b in_address [31:0] $end
$var wire 1 " rst_n $end
$var reg 32 c out_address [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 1 ! clk $end
$var wire 5 d read_addr1 [4:0] $end
$var wire 5 e read_addr2 [4:0] $end
$var wire 32 f read_data1 [31:0] $end
$var wire 32 g read_data2 [31:0] $end
$var wire 1 " rst_n $end
$var wire 5 h write_addr [4:0] $end
$var wire 32 i write_data [31:0] $end
$var wire 1 + write_en $end
$upscope $end
$scope module shifter_branch $end
$var wire 32 j outdata [31:0] $end
$var wire 2 k shift_amt [1:0] $end
$var wire 1 l shift_left $end
$var wire 32 m indata [31:0] $end
$upscope $end
$scope module shifter_jump $end
$var wire 26 n indata [25:0] $end
$var wire 28 o outdata [27:0] $end
$var wire 2 p shift_amt [1:0] $end
$var wire 1 q shift_left $end
$upscope $end
$scope module sign_ext $end
$var wire 16 r bits16_in [15:0] $end
$var wire 32 s bits32_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b101100000100000 s
b101100000100000 r
1q
b10 p
b100101010010110000010000000 o
b1001010100101100000100000 n
b101100000100000 m
1l
b10 k
b10110000010000000 j
b110011 i
b1011 h
b100010 g
b10001 f
b1010 e
b1001 d
b0 c
b0 b
b1001010100101100000100000 a
b0 `
bx _
b100010 ^
b110011 ]
0\
b100010 [
b0 Z
b110011 Y
b1011 X
bx W
b1001010100101100000100000 V
b100010 U
b101100000100000 T
b100101010010110000010000000 S
b0 R
b10110000010000000 Q
b110011 P
b0 O
b100101010010110000010000000 N
b100101010010110000010000000 M
b0 L
b0 K
b0 J
b0 I
b100000 H
b110011 G
b10001 F
b100010 E
b0 D
b10001 C
b100010 B
b0 A
b110011 @
b0 ?
b100000 >
b0 =
b0 <
b0 ;
b10110000010000000 :
b0 9
b10110000010000000 8
b0 7
b0 6
b110011 5
b10110000010000000 4
b10110000010000000 3
b100010 2
01
b0 0
b110011 /
b1011 .
1-
bx ,
0+
b1001010100101100000100000 *
b100101010010110000010000000 )
b100101010010110000010000000 (
b0 '
b10001 &
b100010 %
b101100000100000 $
0#
0"
1!
$end
#5
0!
#10
1!
#15
0!
#20
1!
#25
0!
#30
b10110000010000100 3
b10110000010000100 :
b10110000010000100 Q
b100 6
b100 9
b100 =
b100 L
b100 O
b100 7
b100 ;
1+
1!
1"
#35
0!
#40
1!
#45
0!
#50
1!
#55
0!
#60
1!
#65
0!
#70
1!
#75
0!
#80
1!
#85
0!
#90
1!
#95
0!
#100
1!
